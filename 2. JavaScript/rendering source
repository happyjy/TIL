this.layout = [];
        this.layout.push([{
            // parentNode: "contents",
            type: "EcForm",
            id: "form1",           
            child : [{type: "EcInput", id:"input1"}, 
                    {type: "EcInputEmail", id:"inputEmail"}, 
                    {type: "EcInputNumber", id:"inputNumber"}, 
                    {type: "EcInputNumber", id:"inputNumberMaxLength4", maxlength: "4"}, 
                    // {type: "EcInputAlphabet", id:"inputAlphabet",
                    //     child: [{type: "EcInputNumber", id: "spanId1"}]}
                ]
        }]);

        this.layout.push([{
            // parentNode: "contents",
            type: "EcForm",
            id: "form2",           
            child : [{type: "EcInput", id:"input2"}, 
                    {type: "EcInputAlphabet", id:"inputAlphabet2"}
                    // ,{type: "div", id:"div1", child: [{type: "span", id: "spanId1"}]}
                ]
        }])










// //page.js

// ecount.page = ecount.Class(null, {
//     init: function(parent, pageId, page){
//         page.init();
//         // ecount.page.prototype.init(parent, pageId, page);
//     }
// });

// (function(){
//     ecount.page.factory = function (parent, pageID, page) {        
//         ecount.page.parent = parent;
//         ecount.page.pageID = pageID;
//         ecount.page.page = page;
//         ecount.page.prototype.init(parent, pageID, page);
//     }
// })();
ecount.page = ecount.Class(null, {
    init: function(){
    },
    render: function(layout){
        debugger;
        var g = window;
        var componentLayer = 'P';
        var rec1 = new recursiveRender(layout); 


        var pElements = [];
        var cElements = [];
        function recursiveRender(arg){
            ecount.content = !ecount.content ? [] : ecount.content;
            ecount.newParent = '';  //child node를 가진 element;
            
            arg.forEach(function(val, idx){
                var lowerArr = val[0];
                if( lowerArr instanceof Array ){
                    recursiveRender(lowerArr);
                }else{
                    //child node유무 
                    if(!!lowerArr["child"]){
                        //child node유
                        //child node를 가지고 있는 elements를 생성하고 변수에 저장
                        //child node를 만들고 위 변수에 append
                        pElements = createElement(val);
                        recursiveRender([lowerArr["child"]]);
                    }else{
                        //child node무
                        cElements = createElement(val);
                    }
                }
            })

            var header = document.querySelector(".header");
            pElements.forEach(function(pElement, idx1){
                cElements.forEach(function(cElement, idx2){
                    pElement.append(cElement);
                });
                header.append(pElement);
            });            
            
        }

        function createElement(nodes){
            //create Element
            ecount.elements = [];
            var cntAttr = 0;
            var arrEle = [];
            var element = '';
            nodes.forEach(function(node, idx){
                //Attribute 갯수 파악
                var objCopy = {}
                for (key in node){
                    objCopy[key] = node[key];
                }
                delete objCopy.child;
                numAttr = Object.keys(objCopy).length;
                for( key in node ){
                    if( key === 'type'){
                        element = new g[node[key]];
                        //copy function
                        var objCopy = {}
                        var key;
                        for (key in node){
                            objCopy[key] = node[key];
                        }
                        delete objCopy.child;
                        numAttr = Object.keys(objCopy).length;
                    }else if( key !== 'child'){
                        //element에 attribute가 1개인경우
                        element.ele.setAttribute(key, node[key]);
                        cntAttr++;
                        //attribute를 모두 설정한 경우
                        if(numAttr-1 === cntAttr){
                            ecount.elements.push(element.ele);
                            arrEle.push(element.ele);
                            cntAttr=0;                                    
                        }
                    }
                    // else if ( key === 'child'){
                    //     recursiveRender([node[key]]);
                    // }
                }
            });
            return arrEle;
        }

        // var pEle = ecount.content[0];
        // for(var i = 1; i<ecount.content.length; i++){
        //     pEle.append(ecount.content[i]);
        // }
        // var header = document.querySelector(".header");
        // header.append(pEle);

        //header, content, footer 각 div에 그리는 공통 소스를 작성
        //각화면에서 필요한 것을든 이 클래스를 상속 받는 곳에서 진행하자.

        // 방법1 : elements를 만들면서 rendering 하는 방법? 
        // 방법2 : elements를 만드는것과  rendering을 따로.

        // ### create instance == elements
        // 1. type을 생성할때 type에 해당하는 인스턴스를 생성 하자        
        // 1.1 인스턴스를 생성후 해당하는 attribute를 지정
        // 1.2 생성한 인스턴스를 array에 담는다.
        // array에 push 할때 어떻게 하면 rendering 할때 간편하게 할 수 있을까? 
        // -> nubmering을 해야 할 것같음...
        // : [고민] {type: '', id: '', child: [{type: '', id:'', child: [type: '', id:'' ]}]}
        //  depth에 상관없이 rendering할 수 있는 로직을 고민하자  
        
        // ### rendering 
        // 2. array에 담은 array를 rendering 한다.

        // ### attribute를 설정한뒤에 type을 만들어야 할것같음
        // renderLayout(layout);
        
        // function renderLayout(layout){
        //     var element = '';
        //     var cntAttr = 0;
        //     var numAttr = 0;
        //     var lowerArr = layout[0];
        //     if( lowerArr instanceof Array ){
        //         renderLayout(lowerArr);
        //     }else{
        //         layout.forEach(function(val, idx){
        //             for( key in val){
        //                 if( key === 'type'){
        //                     element = new g[val[key]];
        //                     //copy function
        //                     var objCopy = {}
        //                     var key;
        //                     for (key in val){
        //                         objCopy[key] = val[key];
        //                     }
        //                     delete objCopy.child;
        //                     numAttr = Object.keys(objCopy).length;
        //                 }else if(key === 'child'){
        //                     renderLayout(val['child']);
        //                 }else{
        //                     //element에 attribute가 1개인경우
        //                     element.ele.setAttribute(key, val[key]);
        //                     cntAttr++;
    
        //                     if(numAttr-1 === cntAttr){
        //                         var obj = [];
        //                         cntAttr=0;                                    
        //                         document.querySelector(".contents").append(element.ele);
        //                     }
        //                 }
        //             }
        //         })
        //     }
        // }
        


        /*
        function recursiveRender(arg){
            ecount.content = !ecount.content ? [] : ecount.content;
            var lowerArr = arg[0];
            if( lowerArr instanceof Array ){
                recursiveRender(lowerArr);
            }else{
                //rendring
                var element = '';
                var numAttr = 0;
                var cntAttr = 0;
                var cntEle = 0;
                arg.forEach(function(val, idx){
                    for( key in val ){
                        if( key === 'type'){
                            element = new g[val[key]];
                            //copy function
                            var objCopy = {}
                            var key;
                            for (key in val){
                                objCopy[key] = val[key];
                            }
                            delete objCopy.child;
                            numAttr = Object.keys(objCopy).length;
                        }else if(key === 'child'){
                            // componentLayer = componentNumberSet+'C';
                            recursiveRender(val['child']);
                        }else{
                            //element에 attribute가 1개인경우
                            element.ele.setAttribute(key, val[key]);
                            cntAttr++;

                            if(numAttr-1 === cntAttr){
                                var obj = [];
                                // var componentNumberSet = componentLayer + cntEle;
                                // obj[componentNumberSet] = element.ele;
                                // ecount.content.push(obj);
                                // cntEle++;

                                ecount.content.push(element.ele);
                                cntAttr=0;                                    

                                // document.querySelector(".contents").append(element.ele);
                            }
                        }
                    }
                });
            }
        }

        var pEle = ecount.content[0];
        for(var i = 1; i<ecount.content.length; i++){
            pEle.append(ecount.content[i]);
        }
        var header = document.querySelector(".header");
        header.append(pEle);
*/

        // var parentNodes = {
        //     header: function() {

        //     },
        //     content: function() {

        //     },
        //     footer: function() {

        //     }
        // }
        // var temp = {
        //     type : function(arg){
        //         return document.createElement(arg);
        //     },
        //     attr : function(arg){
        //         return 
        //     }
        // }
    }
});



// if(key === 'parentNode'){
//     if(lowerArr[key] === 'header'){

//     }else if(lowerArr[key] === 'contents'){
        
//     }else if(lowerArr[key] === 'footer'){

//     }
// }




// for( key in lowerArr ){
//     if(key === 'type'){
//         element = new g[lowerArr[key]];
//     }else if(key === 'child'){
//         recursiveRender(lowerArr['child']);
//     }else if(key === 'end' && lowerArr[key]){
//         ecount.content.push(element.ele);                 
//     }else{
//         element.ele.setAttribute(key, lowerArr[key]);
//     }
// }
