<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    /*
        ###문제 설명
            두 개의 단어 begin, target과 단어의 집합 words가 있습니다.
            아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.

            1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
            2. words에 있는 단어로만 변환할 수 있습니다.
            예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -> hot -> dot -> dog -> cog와 같이 4단계를 거쳐 변환할 수 있습니다.

            두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때,
            최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.

        ###제한사항
            각 단어는 알파벳 소문자로만 이루어져 있습니다.
            각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.
            words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.
            begin과 target은 같지 않습니다.
            변환할 수 없는 경우에는 0를 return 합니다.

        ###입출력 예
            begin	  target	   words	                          return
            hit	      cog	     [hot, dot, dog, lot, log, cog]	  4
            hit	      cog	     [hot, dot, dog, lot, log]	      0

        ###입출력 예 설명
            예제 #1
            문제에 나온 예와 같습니다.
            예제 #2
            target인 cog는 words 안에 없기 때문에 변환할 수 없습니다.
    */
    function solution(begin, target, words) {
      let answer = Infinity;
      const visited = [];
      let count = 0;

      recursive(begin, 0);

      function recursive(current, count) {
        if (current === target) {
          answer = Math.min(count, answer);
          return;
        }

        console.log("recursive---------------")
        console.log({
          current,
          count
        });
        words.map((word, index) => {
          let j = word.length - 1;
          let diff = 0;
          while (j !== -1) {
            if (current[j] !== word[j]) diff++;
            j--;
          }

          console.log({
            word,
            index,
            diff,
            visited // [분석필요]여기 visited는 아무것도 안찍히는데 아래 visited는 찍힌다. 왜지? 
          });
          
          // currend word, 주어진 words중 하나와 글자를 비교
          if (diff === 1 && !visited[word]) {
            debugger;
            visited[word] = 1; //true;, *** 이미 if문 조건에 만족해서 사용한 단어 확인하기 위함, visited -> clousre영역
            console.log(visited)
            recursive(word, count + 1); //recursive current word 교체
            visited[word] = 0; //false;
          }
        });
      }

      return answer === Infinity ? 0 : answer;
    }

    console.log("ANSWER: ", solution("hit", "cog", ["hot", "dot", "dog", "lot", "log", "cog"]));
    
  </script>


  <script>
    //분석용
    function solutionAnalysis(begin, target, words) {
      let answer = Infinity;
      const visited = [];
      let count = 0;

      recursive(begin, 0);

      function recursive(current, count) {
        if (current === target) {
          answer = Math.min(count, answer);
          return;
        }

        console.log("recursive---------------")
        console.log({
          current,
          count
        });
        words.map((word, index) => {
          let j = word.length - 1;
          let diff = 0;
          while (j !== -1) {
            if (current[j] !== word[j]) diff++;
            j--;
          }

          console.log({
            word,
            index,
            diff,
            visited // [분석필요]여기 visited는 아무것도 안찍히는데 아래 visited는 찍힌다. 왜지? 
          });
          /*
            # study!
            # visited는 클로저다!
            그렇기 때문에 visited[word] = 0; 이 코드에 의해서 
            결국 visited는 0으로 할당이 되어서 console에도 0으로 나오게 된다.
            그런데 아래 if문 안에 있는 console은 아래와 같이 표현이 된다. 신기하다 
            '''
            [hot: 1, dot: 0, dog: 1, log: 1, lot: 1, …]
              cog: 0
              dog: 0
              dot: 0
              hot: 0
              log: 0
              lot: 0
            '''
          */
          // currend word, 주어진 words중 하나와 글자를 비교
          if (diff === 1 && !visited[word]) {
            debugger;
            visited[word] = 1; //true;, *** 이미 if문 조건에 만족해서 사용한 단어 확인하기 위함, visited -> clousre영역
            console.log(visited)
            recursive(word, count + 1); //recursive current word 교체
            visited[word] = 0; //false;
          }
        });
      }
      return answer === Infinity ? 0 : answer;
    }  
  
  </script>

</body>

</html>
